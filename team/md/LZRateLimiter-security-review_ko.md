# 정보

Pashov Audit Group은 이 분야에서 최고의 스마트 계약 보안 연구원 팀으로 구성되어 있습니다. 총 1000건 이상의 보안 취약점을 보고한 이 그룹은 절대적으로 최고의 감사 여정을 만들기 위해 노력합니다. 100% 보안은 결코 보장할 수 없지만, 경험 많은 연구원들이 귀하의 블록체인 프로토콜을 위해 최선을 다할 것을 보장합니다. 이전 작업은 [여기](https://github.com/pashov/audits)에서 확인하거나 Twitter [@pashovkrum](https://twitter.com/pashovkrum)으로 문의하십시오.

# 면책 조항

스마트 계약 보안 검토는 취약점의 완전한 부재를 보장할 수 없습니다. 이는 시간, 자원 및 전문 지식이 제한된 노력으로, 가능한 한 많은 취약점을 찾으려고 노력합니다. 검토 후 100% 보안을 보장할 수 없으며, 검토를 통해 스마트 계약의 모든 문제를 발견한다고 보장할 수도 없습니다. 후속 보안 검토, 버그 바운티 프로그램 및 온체인 모니터링을 강력히 권장합니다.

# 소개

**Pashov Audit Group**은 **LayerZero-Labs/devtools/packages/oapp-evm** 저장소에 대한 시간 제한 보안 검토를 수행했으며, 애플리케이션의 스마트 계약 구현 보안 측면에 중점을 두었습니다.

# RateLimiter 정보

Layer Zero RateLimiter는 구성 가능한 제한 및 시간 창(time window)을 기반으로 속도 제한을 적용하여 작업 흐름을 제어하도록 설계되었습니다. 진행 중인(inflight) 트랜잭션을 추적하고, 시간이 지남에 따라 사용 가능한 용량을 업데이트하며, 특정 대상 엔드포인트에 대해 허용된 속도를 초과하는 모든 작업을 되돌립니다.

# 위험 분류

| 심각도 | 영향: 높음 | 영향: 중간 | 영향: 낮음 |
| --- | --- | --- | --- |
| **가능성: 높음** | 치명적 | 높음 | 중간 |
| **가능성: 중간** | 높음 | 중간 | 낮음 |
| **가능성: 낮음** | 중간 | 낮음 | 낮음 |

## 영향

- 높음 - 프로토콜의 자산에 상당한 물질적 손실을 초래하거나 사용자 그룹에 상당한 피해를 줍니다.

- 중간 - 프로토콜의 자산에 중간 정도의 물질적 손실을 초래하거나 사용자 그룹에 중간 정도의 피해를 줍니다.

- 낮음 - 프로토콜의 자산에 경미한 물질적 손실을 초래하거나 소수의 사용자 그룹에 피해를 줍니다.

## 가능성

- 높음 - 온체인 조건을 모방한 합리적인 가정 하에 공격 경로가 가능하며, 도난당하거나 손실될 수 있는 자금의 양에 비해 공격 비용이 상대적으로 낮습니다.

- 중간 - 조건부로 인센티브가 주어지는 공격 벡터이지만 여전히 상대적으로 가능성이 높습니다.

- 낮음 - 가정이 너무 많거나 가능성이 희박하거나 공격자가 인센티브가 거의 없거나 전혀 없이 상당한 지분을 투자해야 합니다.

## 심각도 수준에 따른 조치 필요

- 치명적 - 가능한 한 빨리 수정해야 함(이미 배포된 경우).

- 높음 - 수정해야 함(아직 배포되지 않은 경우 배포 전).

- 중간 - 수정해야 함.

- 낮음 - 수정할 수 있음.

# 보안 평가 요약

_검토 커밋 해시_ - [64aeeb59bb649fe7756b3c884057a76237c9e5de](https://github.com/LayerZero-Labs/devtools/tree/64aeeb59bb649fe7756b3c884057a76237c9e5de)

_수정 검토 커밋 해시_ - [16acbdcd0c8357be2821ea506a713bb6904d2ad8](https://github.com/LayerZero-Labs/devtools/tree/16acbdcd0c8357be2821ea506a713bb6904d2ad8)

### 범위

다음 스마트 계약이 감사 범위에 포함되었습니다.

- `RateLimiter`

# 발견 사항

# [L-01] 진행 중인(in flights) 양이 0으로 재설정될 수 있음

RateLimiter의 현재 구현은 `timeSinceLastDeposit`가 창보다 크거나 같을 때 진행 중인 양을 0으로 재설정합니다. 이는 `if` 문에서 처리됩니다.

```solidity
if (timeSinceLastDeposit >= _window) {
    currentAmountInFlight = 0;
    amountCanBeSent = _limit;
}
```

그러나 코드는 `timeSinceLastDeposit`가 `currentAmountInFlight`를 0으로 붕괴(decay)시키기에 충분한 시간인지 확인하지 않습니다. 문제를 보여주기 위해 다음 예를 들어보겠습니다.

상태 1:

- Window = 100
- Limit = 100
- AmountInFlight = 100

그 순간 구성 변경이 발생하고 창과 제한이 다음과 같이 변경됩니다.

- Window = 60
- Limit = 40
- AmountInFlight = 100 (동일하게 유지됨)

마지막 업데이트로부터 60초 후 진행 중인 양은 (100 - 40) = 60이어야 하지만 코드는 이를 0으로 재설정합니다.

`currentAmountInFlight`를 0으로, `amountCanBeSent`를 제한으로 재설정하기 전에 이 시나리오를 고려하십시오. 이것이 원하는 동작인 경우 문서에서 이 가능성에 대해 경고해야 합니다.

# [L-02] 붕괴(decay) 계산의 정밀도 손실

`RateLimiter` 계약에서 시간 경과에 따른 `amountInFlight`의 붕괴는 `_amountCanBeSent()` 함수의 다음 줄을 사용하여 계산됩니다.

```solidity
uint256 decay = (_limit * timeSinceLastDeposit) / _window;
```

이 계산은 지정된 속도 제한 창 동안 `amountInFlight`의 선형 붕괴를 모델링하기 위한 것입니다. 그러나 Solidity의 정수 나눗셈으로 인해 이 접근 방식은 특히 `_window` 기간이 `_limit`보다 훨씬 높거나 `_window`에 비해 작은 `timeSinceLastDeposit` 값을 처리할 때 정밀도 손실을 겪습니다.

`_limit` = 1000, `_window` = 1000000, `timeSinceLastDeposit` = 1이라고 가정합니다.

```solidity
decay = (1000 * 1) / 1000000 = 0
```

여기서 `decay`는 정수 나눗셈으로 인해 0으로 계산되지만, 시간이 어느 정도 흘렀고 부분적인 붕괴가 있어야 합니다.

`decay` 계산의 정밀도 손실을 해결하려면 스케일링 팩터를 도입하여 고정 소수점 산술을 구현하는 것이 좋습니다.

## Layer Zero 의견

내부적으로라도 만 분의 일(ten-thousandth) 단위로 추적하는 것은 복잡하며 의도된 사용 사례에 큰 이점을 제공하지 않습니다. 또한 만 분의 일이 아닌 계산 숫자 단위를 사용하는 기존 \_inflow(...) 및 \_outflow(...) 구현과 함께 RateLimiter를 활용할 계획입니다. 따라서 문서화가 이 문제에 대한 최상의 해결책이라고 봅니다.

[LayerZero-Labs/devtools#905](https://github.com/LayerZero-Labs/devtools/pull/905)

# [L-03] 속도 제한이 적용되지 않음

`_inflow()` 함수는 전달된 `_amount`(`inflowAmount`)만큼 `amountInFlight`를 줄이도록 설계되었으며 하한은 0입니다.

```solidity
function _inflow(uint32 _srcEid, uint256 _amount) internal virtual {
    RateLimit storage rl = rateLimits[_srcEid];
    rl.amountInFlight = _amount >= rl.amountInFlight ? 0 : rl.amountInFlight - _amount;
}
```

그러나 다음 두 가지 시나리오를 상상해 보겠습니다.

- `RateLimiter.RateLimitConfig(1337, 1000, 100);`

**시나리오 1**

- 처음에 시스템은 진행 중인 단위 0개와 전송 가능한 단위 1000개로 시작합니다.
- 1단계에서 `outflow(500)`이 발생하여 사용 가능한 단위가 500개로 줄어들고 현재 500개 단위가 진행 중입니다.
- 2단계에서 `inflow(1000)`이 진행 중인 양을 지워 0으로 되돌리고 전송 가능한 단위 1000개를 복원합니다.
- 마지막으로 3단계에서 또 다른 `outflow(500)`이 처리되어 500개 단위가 진행 중이고 500개 단위가 전송 가능한 상태로 남습니다.

**시나리오 2**

- 초기 상태는 진행 중인 단위 0개와 전송 가능한 단위 1000개입니다.
- 1단계에서 `outflow(500)`이 발생하여 사용 가능한 금액이 500개로 줄어들고 현재 500개 단위가 진행 중입니다.
- 2단계에서 또 다른 `outflow(500)`이 사용 가능한 금액을 완전히 활용하여 1000개 단위가 진행 중이고 0개 단위가 사용 가능한 상태로 남습니다.
- 3단계에서 `inflow(1000)`이 진행 중인 양을 지워 0으로 재설정하고 다시 1000개 단위를 사용할 수 있게 합니다.

두 시나리오 모두 동일한 타임스탬프에서 총 1000개 단위의 유출과 1000개 단위의 유입을 처리하지만 작업 순서에 따라 남은 속도 제한이 다릅니다. 이 불일치는 순 효과가 동일하더라도 유입 및 유출 작업의 순서가 변경되면 속도 제한기가 다르게 동작함을 증명합니다.

동일한 순 작업을 수행하는 사용자는 순전히 작업 순서에 따라 다른 속도 제한을 경험하게 됩니다. 또한 사용자가 속도 제한을 최대화하기 위해 의도적으로 작업을 정렬할 것으로 예상됩니다. **속도 제한기는 순 효과가 동일한 한 작업 순서에 관계없이 제한을 일관되게 적용해야 합니다.**

동일한 타임스탬프 내의 작업 순서가 남은 속도 제한을 변경하지 않도록 계약 로직을 업데이트하는 것을 고려하십시오.

## Layer Zero 의견

흥미롭군요. 우리는 주어진 블록 내의 트랜잭션 순서가 중요하다는 접근 방식을 취했습니다.

현재 RateLimiter는 amountCanBeSent = [0, MAX] 범위를 고정합니다. 타임스탬프(블록) 당 별도의 변수에서 과도한 유입을 추적하고(인바운드 속도 제한이 없으므로) 먼저 감산하는 우선 순위를 지정할 수 있습니다. 그러나 그 반대로 나중에 보상받을 수 있는 과도한 유출(아웃바운드 속도 제한이 있으므로)을 허용할 수는 없습니다. 이 솔루션의 비대칭성은 혼란스럽고 추가 스토리지 읽기/쓰기 비용이 발생합니다.

충분히 큰 제한이 주어지면 이것은 실제로 문제가 되지 않을 것입니다. 따라서 우리는 제한 사항을 설명하는 문서를 추가하기로 결정했습니다.

[LayerZero-Labs/devtools#904](https://github.com/LayerZero-Labs/devtools/pull/904)
