# 소개

**GMD** 프로토콜에 대한 시간 제한 보안 검토가 **pashov**에 의해 수행되었으며, 애플리케이션 구현의 보안 측면에 중점을 두었습니다.

# 면책 조항

스마트 계약 보안 검토는 취약점의 완전한 부재를 절대 확인할 수 없습니다. 이는 시간, 자원 및 전문 지식이 제한된 노력으로 최대한 많은 취약점을 찾으려고 노력하는 것입니다. 검토 후 100% 보안을 보장할 수 없으며, 검토가 스마트 계약의 문제를 발견할 것이라고 보장할 수도 없습니다.

# 프로토콜 개요

GMD 프로토콜은 GMX 위에 구축되었으며 토큰(USDC, ETH, BTC)을 스테이킹 하여 APY를 얻을 수 있습니다. 이것은 수익 애그리게이터(Yield Aggregator) 범주에 속합니다. 사용자는 기본(native) 또는 ERC20 자산으로 볼트에 들어갈 수 있습니다. 관리자는 보상 청구 및 복리(compounding)를 처리합니다. 현재 지원되는 자산은 `USDC`, `WETH` 및 `wBTC`입니다.

# 심각도 분류

| 심각도 | 영향: 높음 | 영향: 중간 | 영향: 낮음 |
| --- | --- | --- | --- |
| **가능성: 높음** | 치명적 (Critical) | 높음 (High) | 중간 (Medium) |
| **가능성: 중간** | 높음 (High) | 중간 (Medium) | 낮음 (Low) |
| **가능성: 낮음** | 중간 (Medium) | 낮음 (Low) | 낮음 (Low) |

# 보안 평가 요약

**_검토 커밋 해시_ - [c27c012fde95d9e2ac40fc0fe795489b76284eee](https://github.com/saulgoodmandev/gmd/tree/c27c012fde95d9e2ac40fc0fe795489b76284eee)**

### 범위

다음 스마트 계약이 감사 범위에 포함되었습니다:

- `final_vault`

심각도 별로 분류된 다음 수의 문제가 발견되었습니다:

- 높음: 0개 문제
- 중간: 7개 문제
- 낮음: 6개 문제
- 정보성: 11개 문제

---

# 발견 사항 요약

| ID | 제목 | 심각도 |
| --- | --- | --- |
| [M-01] | 18 소수점이 아닌 토큰 풀의 하드코드 처리로 인해 프로토콜의 상호 운용성이 제한됨 | 중간 |
| [M-02] | 프로토콜이 관리자 활동에 크게 의존하므로 단일 단계 소유권 이전 패턴은 위험함 | 중간 |
| [M-03] | `addPool`이 너무 많이 호출되면 핵심 기능이 벽돌이 될 수 있음 | 중간 |
| [M-04] | `updatePoolRate` 호출이 누락됨 | 중간 |
| [M-05] | 관리자 권한 작업은 사용자에게 위험할 수 있음 | 중간 |
| [M-06] | 토큰 승인 및 허용량 관리에 결함이 있음 | 중간 |
| [M-07] | 역전된 슬리피지(slippage) 보호 접근 방식을 사용하면 문제가 발생할 수 있음 | 중간 |
| [L-01] | 일관성 없는 입력 검증 | 낮음 |
| [L-02] | 저장소 변수가 쓰이기만 하고 읽히지 않음 | 낮음 |
| [L-03] | `enter`에서 매개변수 검증 누락 | 낮음 |
| [L-04] | `IWETH` 인터페이스에 `WETH`가 가지고 있지 않은 메서드가 있음 | 낮음 |
| [L-05] | 코드가 더 이상 사용되지 않는(deprecated) 메서드를 호출하고 있음 | 낮음 |
| [L-06] | 슬리피지 보호 인수 값이 설정되지 않음 | 낮음 |
| [I-01] | 컴파일러가 ^0.8.0일 때 `SafeMath` 사용 | 정보성 |
| [I-02] | `leaveETH`는 `payable`이면 안 됨 | 정보성 |
| [I-03] | 사용되지 않는 저장소 변수 | 정보성 |
| [I-04] | 코드 전체에 오해의 소지가 있는 주석 | 정보성 |
| [I-05] | 코드가 제대로 형식이 지정되지 않음 | 정보성 |
| [I-06] | 외부 함수에 NatSpec 누락 | 정보성 |
| [I-07] | 의미 없는 주석 | 정보성 |
| [I-08] | 파일 이름과 계약 이름 간의 불일치 | 정보성 |
| [I-09] | 사용하지 않는 import 제거 | 정보성 |
| [I-10] | 모든 `require` 문에 오류 문자열이 있는 것은 아님 | 정보성 |
| [I-11] | 외부 호출을 함께 그룹화할 수 있음 | 정보성 |

# 상세 발견 사항

# [M-01] 18 소수점이 아닌 토큰 풀의 하드코드 처리로 인해 프로토콜의 상호 운용성이 제한됨

## 심각도

**가능성:**
중간, 현 시점에서는 그러한 풀이 추가되지 않았지만 향후 추가될 가능성이 있기 때문입니다.

**영향:**
중간, 프로토콜의 기능을 제한하기 때문입니다.

## 설명

`enter` 메서드는 `USDC` 및 `wBTC` 토큰에 대해 특정 처리를 구현합니다. 이들은 18과 동일하지 않은 소수점을 가지고 있기 때문입니다. 이는 모든 그러한 풀 토큰에 대해 수행되어야 하지만 하드코드 되어 있어 확장할 수 없습니다. 예를 들어 `USDT` 풀은 추가할 수 없습니다.

## 권장 사항

하드코드 된 소수점 접근 방식을 재설계하거나 새로운 18 소수점이 아닌 토큰 풀을 위해 확장 가능한 방식으로 구현하십시오.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [M-02] 프로토콜이 관리자 활동에 크게 의존하므로 단일 단계 소유권 이전 패턴은 위험함

## 심각도

**가능성:**
낮음, 소유권 이전 시 관리자 오류가 필요하기 때문입니다.

**영향:**
높음, 핵심 프로토콜 기능이 벽돌이 되기 때문입니다.

## 설명

OpenZeppelin의 `Ownable` 계약을 상속한다는 것은 단일 단계 소유권 이전 패턴을 사용하고 있음을 의미합니다. 관리자가 새 소유자에 대해 잘못된 주소를 제공하면 `onlyOwner`로 표시된 메서드를 다시 호출할 수 없게 됩니다. 이를 수행하는 더 좋은 방법은 2단계 소유권 이전 접근 방식을 사용하는 것인데, 새 소유자가 이전되기 전에 먼저 새 권한을 청구해야 합니다.

## 권장 사항

`Ownable` 대신 OpenZeppelin의 `Ownable2Step`을 사용하십시오.

## 논의

**pashov**: 클라이언트가 문제를 인지했습니다.

# [M-03] `addPool`이 너무 많이 호출되면 핵심 기능이 벽돌이 될 수 있음

## 심각도

**가능성:**
낮음, 악의적인 관리자나 큰 관리자 오류가 필요하기 때문입니다.

**영향:**
높음, 핵심 프로토콜 기능이 벽돌이 되기 때문입니다.

## 설명

`addPool` 메서드는 `poolInfo` 배열에 항목을 푸시 합니다. `swapGLPout` 및 `recoverTreasuryTokensFromGLP`와 같은 메서드에는 전체 배열을 반복하는 내부 호출(`GLPbackingNeeded`)이 있습니다. 너무 많은 풀이 추가되면 해당 메서드에 대한 모든 호출은 배열을 반복하는 데 너무 많은 가스가 필요하며, 이 비용이 블록 가스 제한을 초과하면 핵심 기능의 DoS 상황으로 이어질 것입니다.

## 권장 사항

추가할 수 있는 풀의 수를 제한하십시오(예: 50개).

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [M-04] `updatePoolRate` 호출이 누락됨

## 심각도

**가능성:**
중간, 일시 중지된 후 다시 시작된 풀에 대해서만 발생하기 때문입니다.

**영향:**
중간, 큰 손실로 이어지기는 어렵기 때문입니다.

## 설명

풀의 `totalStaked` 금액이 업데이트될 때마다 `updatePoolRate` 메서드가 호출되어 `EarnRateSec`를 업데이트합니다. `pauseReward` 메서드의 경우는 그렇지 않습니다. 이 메서드는 `totalStaked` 금액을 변경하는 `updatePool`을 호출합니다. 이제 풀이 일시 중지되었다가 다시 시작되고 `updatePool`이 호출되면 `EarnRateSec`가 업데이트되지 않았기 때문에 원래보다 적은 보상을 계산하게 됩니다.

## 권장 사항

`pauseReward`의 `updatePool` 호출 후 `updatePoolRate`를 호출하십시오.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [M-05] 관리자 권한 작업은 사용자에게 위험할 수 있음

## 심각도

**가능성:**
낮음, 악의적이거나 침해된 관리자가 필요하기 때문입니다.

**영향:**
높음, 프로토콜이 벽돌이 될 수 있기 때문입니다.

## 설명

`updateOracle`, `updateRouter` 및 `updateRewardRouter` 메서드는 관리자가 제어하고 언제든지 호출할 수 있습니다. `PoolInfo`의 `withdrawable` 속성도 마찬가지입니다. 악의적이거나 침해된 관리자는 존재하지 않는 주소를 제공하거나 모든 풀에 대해 `withdrawable` 속성을 false로 설정하여 프로토콜 사용자에 대한 DoS로 이어질 수 있습니다.

## 권장 사항

단일 관리자 역할 대신 역할 기반 액세스 제어 접근 방식을 사용하는 것과 중요한 관리자 작업에 대한 타임락(timelock)을 사용하는 것을 고려하십시오.

## 논의

**pashov**: 클라이언트가 문제를 인지했습니다.

# [M-06] 토큰 승인 및 허용량 관리에 결함이 있음

## 심각도

**가능성:**
중간, 특수 유형의 토큰에서만 문제가 되기 때문입니다.

**영향:**
중간, 제한된 자금 손실로 이어질 수 있기 때문입니다.

## 설명

계약의 승인 및 허용량과 관련된 몇 가지 문제가 있습니다. 하나는 `swaptoGLP` 메서드가 다른 계약이 토큰을 지출하도록 승인하지만, 일부 토큰(예: `USDT`)에는 승인 경쟁 조건 보호 기능이 있어 `approve`를 호출하기 전에 허용량이 이미 0이거나 `UINT_MAX`여야 한다는 것입니다. 그렇지 않은 경우 호출이 되돌려져(revert) `swaptoGLP`와 함께 DoS 상황이 발생할 수 있습니다. 이를 완화하려는 아이디어가 있었던 것 같습니다. `swaptoGLP` 메서드를 호출한 후 모든 위치(`convertDust` 제외)에서 0 허용량에 대한 `approve` 호출이 있지만 잘못된 주소로 수행됩니다. `swaptoGLP`는 항상 `poolGLP`를 승인하지만 0 허용량 `approve` 호출은 `_GLPRouter`가 허용량을 갖지 않아야 할 때 항상 `_GLPRouter`에 수행됩니다.

## 권장 사항

`poolGLP` 주소에 대해 각 `swaptoGLP` 호출 후 허용량을 0으로 설정하십시오.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [M-07] 역전된 슬리피지(slippage) 보호 접근 방식을 사용하면 문제가 발생할 수 있음

## 심각도

**가능성:**
낮음, 동시에 하나 이상의 특수 조건이 필요하기 때문입니다.

**영향:**
중간, 프로토콜에서 제한된 금액의 자금 손실로 이어질 수 있기 때문입니다.

## 설명

`leaveETH` 및 `leave` 메서드 모두 `slippage` 저장소 변수를 사용하여 볼트를 떠나는 사용자에 대한 슬리피지 보호를 구현합니다. 문제는 슬리피지 보호가 비정상적인 접근 방식으로 수행되어 문제가 발생할 수 있다는 것입니다. 두 메서드 모두 `min_receive` 매개변수가 있는 `swapGLPto` 메서드를 호출하며, 이는 `GLPRouter`의 `unstakeAndRedeemGlp` 메서드로 전달됩니다. 슬리피지 보호에 대한 일반적인 접근 방식은 스왑 후 받을 것으로 예상되는 토큰 양을 계산하고(예: 100 $TKN), 여기에 일정 슬리피지 허용 오차 비율을 적용하는 것입니다. 허용 오차가 5%이면 예상되는 최소 수신 토큰은 95 $TKN입니다. 이 프로토콜은 다른 접근 방식을 구현했는데, 더 작은 예상 수신 값을 제공하는 대신 실제로 스왑을 위해 보낼 값을 팽창시킵니다.

```solidity
uint256 percentage = 100000 - slippage;
uint256 glpPrice = priceFeed.getGLPprice().mul(percentage).div(100000);
uint256 glpOut = amountOut.mul(10**12).mul(tokenPrice).div(glpPrice).div(10**30);
```

보시다시피, 작동 방식은 $GLP의 더 낮은 가격을 "기대"하는 것입니다. 즉, 프로토콜은 항상 스왑에 필요한 것보다 더 많은 $GLP를 보냅니다. 이제 슬리피지 보호가 예치 수수료보다 큰 경우, 볼트에 입금하고 인출하는 과정을 여러 번 반복하여 풀의 $GLP 잔액을 고갈시키는 그리핑(griefing) 공격 벡터로 사용될 수 있습니다.

## 권장 사항

프로토콜 대신 사용자가 슬리피지 비용을 지불하도록 `leave` 메서드를 재설계하는 것을 고려하십시오.

## 논의

**pashov**: 클라이언트가 문제를 인지했습니다.

# [L-01] 일관성 없는 입력 검증

`APR`은 `addPool` 호출 시 최대값이 1599이지만 `setAPR` 호출 시 3999일 수 있습니다. 또한 `glpFees`는 풀을 추가할 때 최대값이 700이지만 설정자(setter) 메서드 `setGLPFees`를 호출할 때는 999일 수 있습니다. 시스템 전체에서 입력 검증이 일관적인지 확인하십시오.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [L-02] 저장소 변수가 쓰이기만 하고 읽히지 않음

`GLPbacking` 저장소 변수는 `updateGLPbackingNeeded`에서 쓰이기만 하고 실제로는 읽히지 않습니다. 이는 `updateGLPbackingNeeded` 호출이 아무런 효과가 없으므로 쓸모없다는 것을 의미합니다. 외부 행위자가 "GLPbacking"을 얻으려면 `GLPbackingNeeded` 조회(view) 함수를 호출하면 됩니다. `updateGLPbackingNeeded` 메서드와 `GLPbacking` 저장소 변수를 제거하거나, 일부 로직이 구현되지 않은 경우 추가하십시오.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [L-03] `enter`에서 매개변수 검증 누락

`enterETH`에는 `msg.value > 0`인지 확인하는 기능이 있지만 `enter`는 `_amountin > 0`인지 확인하지 않습니다. 해당 확인을 추가하십시오.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [L-04] `IWETH` 인터페이스에 `WETH`가 가지고 있지 않은 메서드가 있음

`safeTransfer` 메서드는 일반적인 `IWETH` 인터페이스의 일부가 아니며 코드에서 실제로 사용되지 않으므로 제거해야 합니다.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [L-05] 코드가 더 이상 사용되지 않는(deprecated) 메서드를 호출하고 있음

`SafeERC20` 라이브러리의 `safeApprove` 메서드는 더 이상 사용되지 않으므로 사용해서는 안 됩니다.

## 논의

**pashov**: 클라이언트가 문제를 인지했습니다.

# [L-06] 슬리피지 보호 인수 값이 설정되지 않음

`swaptoGLP` 메서드는 `_minUsdg` 및 `_minGlp` 모두에 대해 0 값을 갖는 `mintAndStakeGlp` 호출을 수행합니다. 또한 `recoverTreasuryTokensFromGLP`에서 `swapGLPto` 메서드 호출의 `min_receive` 매개변수도 0입니다. `GLP`의 역학/토크노믹스로 인해 악용되기는 어렵지만 외부 함수에서 사용자가 `minReceive` 매개변수를 제공하고 이를 `swapToGLP` 호출로 전달하는 것이 현명합니다.

## 논의

**pashov**: 클라이언트가 문제를 인지했습니다.

# [I-01] 컴파일러가 ^0.8.0일 때 `SafeMath` 사용

컴파일러가 ^0.8.0일 때는 내장된 언더/오버플로 검사가 있으므로 `SafeMath`를 사용할 필요가 없습니다.

## 논의

**pashov**: 클라이언트가 문제를 인지했습니다.

# [I-02] `leaveETH`는 `payable`이면 안 됨

`leaveETH` 메서드는 ETH를 전송하기만 하므로 서명에서 `payable` 키워드를 제거해야 합니다.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [I-03] 사용되지 않는 저장소 변수

저장소 변수 `gdUSDC`는 사용되지 않으므로 제거해야 합니다.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [I-04] 코드 전체에 오해의 소지가 있는 주석

코드에 `usdc` 또는 `gdUSDC`라는 단어가 포함된 거의 모든 주석은 오해의 소지가 있고 오래되었으므로 제거하거나 업데이트해야 합니다.

## 논의

**pashov**: 클라이언트가 문제를 인지했습니다.

# [I-05] 코드가 제대로 형식이 지정되지 않음

코드에서 포맷터(formatter)를 실행하십시오. 예를 들어 `prettier-solidity` 플러그인을 사용하십시오.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [I-06] 외부 함수에 NatSpec 누락

의도와 서명이 명확하도록 모든 외부 함수에 NatSpec 문서를 추가하십시오.

## 논의

**pashov**: 클라이언트가 문제를 인지했습니다.

# [I-07] 의미 없는 주석

`// Info of each user that stakes LP tokens.`라는 주석은 의미가 없으며 지금은 사라진 저장소 변수와 관련된 것으로 보입니다. 제거하십시오.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [I-08] 파일 이름과 계약 이름 간의 불일치

파일 이름은 `final_vault.sol`이지만 계약 이름은 `vault`입니다. 파일 이름을 `Vault.sol`로 바꾸고 계약 이름을 `Vault`로 바꾸십시오.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [I-09] 사용하지 않는 import 제거

`import "@openzeppelin/contracts/token/ERC20/ERC20.sol";` import는 사용되지 않으므로 제거하십시오.

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.

# [I-10] 모든 `require` 문에 오류 문자열이 있는 것은 아님

프로젝트가 0.8.4 버전보다 최신 컴파일러를 사용하고 있으므로 오류 상황에 대해 Solidity Custom Errors를 사용하는 것이 가장 좋습니다. 모든 require 문을 이러한 사용자 지정 오류로 대체하십시오.

## 논의

**pashov**: 클라이언트가 문제를 인지했습니다.

# [I-11] 외부 호출을 함께 그룹화할 수 있음

`RewardRouter` 스마트 계약에는 `handleRewards` 함수가 있으며, 이는 `cycleRewardsETHandEsGMX` 및 `_cycleRewardsETH methods` 대신 사용할 수 있습니다 - [코드](https://arbiscan.io/address/0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1#code)

## 논의

**pashov**: 클라이언트가 문제를 수정했습니다.
