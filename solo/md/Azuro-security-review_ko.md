# 소개

**Azuro** 프로토콜에 대한 시간 제한 보안 검토가 pashov에 의해 수행되었으며, 애플리케이션 구현의 보안 측면에 중점을 두었습니다.

# 면책 조항

스마트 계약 보안 검토는 취약점의 완전한 부재를 절대 확인할 수 없습니다. 이는 시간, 자원 및 전문 지식이 제한된 노력으로 최대한 많은 취약점을 찾으려고 노력하는 것입니다. 검토 후 100% 보안을 보장할 수 없으며, 검토가 스마트 계약의 문제를 발견할 것이라고 보장할 수도 없습니다.

# 프로토콜 개요

Azuro는 탈중앙화 베팅 프로토콜입니다. 누구나 스마트 계약에 연결하는 프런트엔드 서비스를 시작할 수 있으며 해당 프런트엔드를 통해 이루어진 각 베팅에 대해 제휴 보너스를 받을 수 있습니다. 축구 경기와 같은 다양한 베팅 이벤트를 호스팅 할 수 있습니다. 배당률은 초기화를 위해 데이터 피드 제공자(오라클)에 의해 한 번 제공된 다음 플랫폼의 베팅에 따라 변경됩니다. 사용자 베팅은 사용자 지갑의 NFT로 자동 변환됩니다.

# 심각도 분류

| 심각도 | 영향: 높음 | 영향: 중간 | 영향: 낮음 |
| --- | --- | --- | --- |
| **가능성: 높음** | 치명적 (Critical) | 높음 (High) | 중간 (Medium) |
| **가능성: 중간** | 높음 (High) | 중간 (Medium) | 낮음 (Low) |
| **가능성: 낮음** | 중간 (Medium) | 낮음 (Low) | 낮음 (Low) |

# 보안 평가 요약

**_검토 커밋 해시_ - [7c6f477ca345ef8ca7a1c1f697daf479174b7060](https://github.com/Azuro-protocol/Azuro-v2/tree/7c6f477ca345ef8ca7a1c1f697daf479174b7060)**

### 범위

다음 스마트 계약이 감사 범위에 포함되었습니다:

- `Access`
- `AzuroBet`
- `Core`
- `CoreBase`
- `Factory`
- `LP`
- `interface/**`
- `libraries/**`
- `utils/**`

`SafeOracle`, `FreeBet`, `BetExpress` 및 `LiveCore` 계약은 이번 감사 범위에서 제외되었습니다.

심각도 별로 분류된 다음 수의 문제가 발견되었습니다:

- 높음: 0개 문제
- 중간: 5개 문제
- 낮음: 7개 문제
- 정보성: 12개 문제

---

# 발견 사항 요약

| ID | 제목 | 심각도 |
| --- | --- | --- |
| [M-01] | `claimTimeout`이 계정의 첫 번째 청구에 대해 확인되지 않음 | 중간 |
| [M-02] | 프로토콜은 더 작은 소수점 토큰을 베팅 토큰으로 사용할 수 없음 | 중간 |
| [M-03] | 관리자 입력 검증 누락 | 중간 |
| [M-04] | `OwnableUpgradeable`은 단일 단계 소유권 이전을 사용함 | 중간 |
| [M-05] | 관리자 권한은 위험함 | 중간 |
| [L-01] | `_mint`보다 `_safeMint` 사용 선호 | 낮음 |
| [L-02] | 이벤트 방출 누락 | 낮음 |
| [L-03] | 프로토콜은 fee-on-transfer 또는 리베이스 메커니즘이 있는 토큰과 작동하지 않음 | 낮음 |
| [L-04] | `claimAffiliateReward`에서 `coreAffRewards` 매핑이 확인되지 않음 | 낮음 |
| [L-05] | `azuroBet.mint()` 호출이 재진입할 수 있음 | 낮음 |
| [L-06] | 코드에 기술 문서가 부족함 | 낮음 |
| [L-07] | 사용되지 않는 메서드가 의도한 대로 작동하지 않음 | 낮음 |
| [I-01] | 우선순위가 불확실한 연산자 주위에 중괄호 사용 | 정보성 |
| [I-02] | `stopCondition` 메서드는 조건을 중지할 뿐만 아니라 시작할 수도 있음 | 정보성 |
| [I-03] | 필수적이지 않은 로직을 오프체인 계산으로 이동 | 정보성 |
| [I-04] | 불필요한 코드 | 정보성 |
| [I-05] | 코드 내 열린 `TODO` | 정보성 |
| [I-06] | 사용되지 않는 import | 정보성 |
| [I-07] | 인터페이스에서 상속된 메서드에 `override` 키워드가 누락됨 | 정보성 |
| [I-08] | 안전한 pragma 문 사용 | 정보성 |
| [I-09] | 초기화 메서드의 작은 문제들 | 정보성 |
| [I-10] | NatSpec의 오타 | 정보성 |
| [I-11] | 잘못된 import | 정보성 |
| [I-12] | 문자열 오류가 있는 require 문 대신 사용자 정의 오류 사용 고려 | 정보성 |

# 상세 발견 사항

# [M-01] `claimTimeout`이 계정의 첫 번째 청구에 대해 확인되지 않음

## 심각도

**가능성:**
، 높음, 각 계정의 첫 번째 청구에 대해 발생하기 때문

**영향:**
낮음, 자금 손실은 없지만 코드가 의도한 대로 작동하지 않기 때문

## 설명

`LP.sol`의 `claimRewards`에는 다음과 같은 확인이 있습니다:

```solidity
if ((block.timestamp - reward.claimedAt) < claimTimeout)
    revert ClaimTimeout(reward.claimedAt + claimTimeout);
```

이는 기본적으로 보상을 청구하는 계정이 최소 `claimTimeout` 시간 동안 기다리도록 강제합니다. 문제는 `addReserve`에서 보상 금액은 설정되지만 `reward.claimedAt`은 `block.timestamp`로 설정되지 않는다는 것입니다. 이는 주소에 대해 `claimRewards`가 처음 호출될 때 `reward.claimedAt`이 0이 됨을 의미하므로 시간이 아직 지나지 않았더라도 `claimTimeout` 확인이 통과됩니다.

## 권장 사항

`addReserve`에서 보상 금액을 설정할 때 `reward.claimedAt = block.timestamp`도 설정하십시오.

# [M-02] 프로토콜은 더 작은 소수점 토큰을 베팅 토큰으로 사용할 수 없음

## 심각도

**가능성:**
중간, 그러한 토큰은 널리 사용되고 허용되기 때문

**영향:**
중간, 프로토콜의 기능을 제한하기 때문

## 설명

프로토콜의 현재 구현은 베팅 및 유동성 제공을 위해 `DAI`와 같은 높은(예: 18) 소수점 토큰만 사용할 수 있도록 허용합니다. 이는 유동성 추가를 위해 1e12보다 작을 수 없는 `LP.sol`의 `minDepo` 속성과 `amount`가 1e12보다 커야 하는 `Core.sol`의 `putBet`에 있는 `amount` 확인에 의해 강제됩니다. 더 작은 소수점 토큰(예: `USDT`, `USDC`, `wBTC`)을 사용해야 하는 경우 사용자와 LP는 플랫폼과 상호 작용하기 위해 매우 많은 양의 자본을 보유해야 합니다.

## 권장 사항

`minDepo` 및 `amount`에 대한 검증을 다시 검토하십시오. 한 가지 가능한 접근 방식은 토큰의 소수점을 기반으로 이를 계산하는 것입니다.

# [M-03] 관리자 입력 검증 누락

## 심각도

**가능성:**
낮음, 악의적/침해된 관리자 또는 관리자 측의 오류가 필요하기 때문

**영향:**
높음, 중요한 프로토콜 기능이 마비될 수 있기 때문

## 설명

`LP.sol`의 `claimTimeout` 속성이 설정자(setter) 함수와 `initialize` 모두에서 매우 큰 값을 갖지 않는지 확인하지 않습니다. `withdrawTimeout`의 설정자 함수도 마찬가지입니다. 또한 `LP.sol`의 `checkFee` 메서드에는 느슨한 검증이 있습니다. 모든 수수료의 최대 합계는 100%보다 훨씬 낮아야 합니다. 마지막으로 `LP.sol`의 `shiftGame`의 `startsAt` 인수는 현재 타임스탬프 이후가 아닌지 검증되지 않습니다.

## 권장 사항

`claimTimeout` 및 `withdrawTimeout`에 대한 상한을 추가하십시오. 모든 수수료의 최대 합계를 더 낮게(예: 20%) 만드십시오. `shiftGame`에서 `startsAt >= blockTimestamp`인지 확인하십시오.

# [M-04] `OwnableUpgradeable`은 단일 단계 소유권 이전을 사용함

## 심각도

**가능성:**
낮음, 관리자 측의 오류가 필요하기 때문

**영향:**
높음, 중요한 프로토콜 기능이 마비될 수 있기 때문

## 설명

단일 단계 소유권 이전은 소유권을 이전하거나 관리자 권한을 이전할 때 잘못된 주소가 전달되면 해당 역할을 영원히 잃을 수 있음을 의미합니다. 프로토콜에 대한 소유권 패턴 구현은 단일 단계 전송이 구현된 `OwnableUpgradeable.sol`에 있습니다. 이는 프로토콜 전체에서 `onlyOwner`로 표시된 모든 메서드에 문제가 될 수 있으며, 그중 일부는 핵심 프로토콜 기능입니다.

## 권장 사항

2단계 소유권 이전 패턴을 사용하는 것이 모범 사례입니다. 즉, 소유권 이전이 "보류(pending)" 상태가 되고 새 소유자가 새 권한을 청구해야 합니다. 그렇지 않으면 이전 소유자가 여전히 계약을 제어합니다. OpenZeppelin의 `Ownable2Step` 계약을 사용하는 것을 고려하십시오.

# [M-05] 관리자 권한은 위험함

## 심각도

**가능성:**
낮음, 악의적/침해된 관리자가 필요하기 때문

**영향:**
높음, 러그 풀(rug pull)이 실행될 수 있기 때문

## 설명

악의적이거나 침해된 관리자는 다음과 같은 방식으로 100% 러그 풀을 실행할 수 있습니다:

1. `LP` 관리자가 악성 `core`를 `LP`에 추가하기 위해 `Factory` 계약을 호출합니다.
2. 악성 `core`는 `resolveAffiliateReward` 메서드가 호출될 때 `LP` 계약 잔액을 반환합니다.
3. 이제 가짜 `core`를 인수로 사용하여 `claimAffiliateReward`를 호출하면 `LP` 잔액의 100%가 도난당하게 됩니다.

동일한 내용이 `withdrawPayout`에도 적용됩니다.

## 권장 사항

새 `coreType`을 추가하거나 `plugCore`를 호출하는 프로세스를 더 안전하게 만드십시오. 한 가지 가능한 접근 방식은 `core`가 `LP`에 추가되기 전에 시간 지연을 추가하여 해당 시점까지 요청이 보류되도록 하는 것입니다.

# [L-01] `_mint`보다 `_safeMint` 사용 선호

`Access::grantRole`과 `LP::_addLiquidity` 모두 ERC721의 `_mint` 메서드를 사용하는데, 여기에는 NFT를 발행할 계정이 ERC721 토큰을 처리할 수 있는 스마트 계약인지 확인하는 과정이 누락되어 있습니다. `_safeMint` 메서드는 정확히 이 작업을 수행하므로 `_mint`보다 선호하되, `_safeMint`에 대한 호출이 재진입할 수 있으므로 항상 `nonReentrant` 수정자(modifier)를 추가하십시오.

# [L-02] 이벤트 방출 누락

`LP.sol`의 `changeLockedLiquidity` 메서드는 이벤트를 방출하지 않아 오프체인 모니터링에 좋지 않을 수 있습니다. 유동성 추가 및 감소의 두 경로 모두에서 적절한 이벤트를 방출하십시오. `AzuroBet::setURI`에도 동일한 문제가 존재합니다. 상태 변경 시 이벤트를 방출하십시오.

# [L-03] 프로토콜은 fee-on-transfer 또는 리베이스 메커니즘이 있는 토큰과 작동하지 않음

블록체인의 일부 토큰은 계정 잔액을 임의로 변경합니다. 예로는 fee-on-transfer 토큰과 리베이스 메커니즘이 있는 토큰이 있습니다. `LP` 계약이 보유한 금액이 실제로 회계 처리된 금액보다 적을 수 있으므로 이러한 토큰에 대한 구체적인 처리는 없습니다. 이러한 토큰을 처리하는 것을 고려하거나 프로토콜에서 지원하려는 ERC20 토큰 목록을 문서화하십시오.

# [L-04] `claimAffiliateReward`에서 `coreAffRewards` 매핑이 확인되지 않음

`LP.sol`에서 코어에 대해 `claimAffiliateReward`를 호출할 때 코어가 청구를 위해 실제로 충분한 보상을 얻었는지 확인하기 위해 `coreAffRewards` 매핑을 확인하지 않습니다. 매핑에 대한 검증을 추가하십시오.

# [L-05] `azuroBet.mint()` 호출이 재진입할 수 있음

`azuroBet`의 `mint` 함수는 수신자가 그러한 토큰을 처리할 수 있는 스마트 계약인지 확인하기 위해 외부 호출을 수행합니다. 수신자가 악의적일 수 있고 재진입 호출을 수행할 수 있으므로 이 호출은 안전하지 않습니다. `Core.sol`의 메서드에 `nonReentrant` 수정자를 추가하는 것을 고려하십시오.

# [L-06] 코드에 기술 문서가 부족함

코드 전체의 여러 곳에서 개발자의 가정이 명확하지 않고 일부 수학 공식이 사용되지만 이유가 명확하지 않기 때문에 기술 문서가 필요합니다. 이에 대한 한 가지 예는 `CoreBase::_applyOdds`입니다. 사용자와 감사자가 더 쉽게 이해할 수 있도록 복잡한 코드에 기술 문서를 추가하는 것을 고려하십시오. 또한 기존 NatSpec 문서를 다시 검토하고 여러 곳에서 누락된 모든 매개변수에 대한 정보를 추가하십시오.

# [L-07] 사용되지 않는 메서드가 의도한 대로 작동하지 않음

`LiquidityTree`의 `getLeavesAmount` 메서드는 `node` 금액만 반환하며 리프(leaf)에 있는 금액은 고려하지 않습니다. 메서드가 어디에서도 사용되지 않으므로 제거하는 것을 고려하십시오.

# [I-01] 우선순위가 불확실한 연산자 주위에 중괄호 사용

`Access::roleGranted`에서 다음 코드를 볼 수 있습니다:

```solidity
return userRoles[account] & roleBit == roleBit;
```

Solidity에서 `&` 연산자는 `==`보다 먼저 실행되지만 이것이 항상 명확하지는 않을 수 있으며 다른 언어에서는 다를 수 있습니다. 연산자 우선순위를 명확히 하기 위해 `userRoles[account] & roleBit` 주위에 중괄호를 추가하는 것이 좋습니다.

# [I-02] `stopCondition` 메서드는 조건을 중지할 뿐만 아니라 시작할 수도 있음

`stopCondition` 메서드와 해당 이벤트는 조건을 중지하는 기능만 있는 의도를 보여주지만, 다시 시작할 수도 있습니다. 예를 들어 `updateConditionStatus`와 같이 다른 단어를 사용하십시오.

# [I-03] 필수적이지 않은 로직을 오프체인 계산으로 이동

`game.conditions` 배열은 `LP::addCondition`에서 기록되지만 시스템에서 읽히지 않습니다. 이 로직을 프런트엔드 서비스로 이동하는 것을 고려하십시오.

# [I-04] 불필요한 코드

`assert(affiliateProfits[i] >= oldProfit - newProfit);` 확인은 불필요합니다. 확인된 조건이 거짓이면 다음 코드 줄인 `affiliateProfits[i] -= (oldProfit - newProfit).toUint128();`이 실패하기 때문입니다. 불필요한 코드를 제거하는 것을 고려하십시오.

# [I-05] 코드 내 열린 `TODO`

`CoreBase.sol`의 `_resolveCondition` 메서드에 열린 `TODO`가 있습니다. 수정하거나 삭제하는 것을 고려하십시오.

# [I-06] 사용되지 않는 import

`IBet.sol`의 모든 import는 사용되지 않으므로 제거하는 것을 고려하십시오. `Core`의 `OwnableUpgradeable` import도 마찬가지입니다.

# [I-07] 인터페이스에서 상속된 메서드에 `override` 키워드가 누락됨

`CoreBase`의 `changeOdds` 메서드에 `override` 키워드가 누락되었습니다. 추가하는 것을 고려하십시오.

# [I-08] 안전한 pragma 문 사용

항상 안정적인 pragma 문을 사용하여 컴파일러 버전을 고정하십시오. 또한 코드베이스 전체에서 다양한 버전의 컴파일러가 사용되므로 하나만 사용하십시오. 마지막으로 컴파일러의 버그 수정 및 최적화를 사용하기 위해 버전을 최신 버전으로 업그레이드하는 것을 고려하십시오.

# [I-09] 초기화 메서드의 작은 문제들

`AzuroBet::initialize`에서 `__ERC165_init` 호출이 누락되어 추가해야 합니다. 또한 `Access::initialize`에서 `__Ownable_init_unchained`가 호출되는데, 이는 `Context` 이니셜라이저를 호출하지 않으므로 대신 `__Ownable_init`을 호출하십시오.

# [I-10] NatSpec의 오타

`IWNative`에서 NatSpec에 두 개의 오타가 있습니다 - `interrface` -> `interface` 및 `vbased` -> `based`. 또한 NatSpec을 `pragma` 문 이전이 아니라 인터페이스 선언 바로 위로 이동하십시오.

# [I-11] 잘못된 import

`Factory`의 `ICore` import를 사용되는 `ICoreBase`로 변경하십시오.

# [I-12] 문자열 오류가 있는 require 문 대신 사용자 정의 오류 사용 고려

사용자 정의 오류는 계약 크기를 줄이고 프로토콜과 더 쉽게 통합할 수 있습니다. 문자열 오류가 있는 require 문 대신 사용하는 것을 고려하십시오.
