# 소개

**Bloom** 프로토콜에 대한 시간 제한 보안 검토가 **pashov**에 의해 수행되었으며, 애플리케이션 구현의 보안 측면에 중점을 두었습니다.

# 면책 조항

스마트 계약 보안 검토는 취약점의 완전한 부재를 절대 확인할 수 없습니다. 이는 시간, 자원 및 전문 지식이 제한된 노력으로 최대한 많은 취약점을 찾으려고 노력하는 것입니다. 검토 후 100% 보안을 보장할 수 없으며, 검토가 스마트 계약의 문제를 발견할 것이라고 보장할 수도 없습니다. 후속 보안 검토, 버그 바운티 프로그램 및 온체인 모니터링을 강력히 권장합니다.

# **pashov** 소개

Krum Pashov 또는 **pashov**는 독립적인 스마트 계약 보안 연구원입니다. 다양한 프로토콜에서 수많은 보안 취약점을 발견한 그는 보안 연구 및 검토에 시간과 노력을 투자하여 블록체인 생태계와 프로토콜에 기여하기 위해 최선을 다합니다. Twitter [@pashovkrum](https://twitter.com/pashovkrum)으로 연락할 수 있습니다.

# **Bloom** 소개

Bloom은 대출자(lender)와 차입자(borrower)가 토큰을 예치하고 포지션을 레버리지하여 실질적으로 연방 기금 금리를 획득하는 미국 재무부 채권 ETF($ib01)로 교환할 수 있는 프로토콜이며, 재무부에 대한 소정의 수수료가 있습니다. 프로토콜은 단계(`Commit`, `ReadyPreHoldSwap`, `PendingPreHoldSwap`, `Holding` 등)로 작동하며 각 `BloomPool`에는 기본 ETF 기간을 따르는 기간이 있습니다.

사용 사례 예시는 다음과 같습니다:

1. 앨리스(KYC 완료)가 차입자로서 20k 토큰을 입금합니다. 프로토콜에 이것은 20k \* 레버리지의 차입 주문입니다. 20k 예치된 토큰은 담보로 사용됩니다.
2. 밥(익명)이 20k \* 레버리지 토큰을 대출자 주문으로 입금합니다.
3. 이제 크리스가 와서 대출자로서 15 토큰을 입금하지만, 차입 및 대출 수요가 완벽하게 일치했기 때문에 그의 토큰은 사용되지 않고 그에게 다시 전송됩니다(선착순 원칙).
4. 커밋(Commit) 단계가 종료됩니다. 즉, 일치하는 수요(대출자 또는 차입자 입금)가 없는 모든 나머지 토큰은 다시 전송될 수 있으며, 이제 풀은 일치하는 대출/차입 수요 토큰을 보유합니다. 이것은 `ReadyPreHoldSwap` 상태입니다. 풀은 자금을 보유하고 있으며 아직 ETF로 교환되지 않았습니다.
5. 이제 일치된 수요 토큰을 사용하여 스왑을 시작합니다.
6. 화이트리스트에 있는 주소(차입자 화이트리스트와 별도)가 기본 토큰과 "빌리 토큰(billy token)"(재무부 채권 ETF 토큰) 간의 실제 스왑을 실행합니다.
7. 이제 풀 계약은 만기까지 빌리 토큰을 보유하는 `Holding` 상태가 됩니다.
8. 거기서 풀 단계가 끝난 후 누구나 "보유 후 스왑(post hold swap)"을 시작할 수 있습니다.
9. 다시 화이트리스트에 있는 주소가 실제 스왑을 실행하지만 이번에는 빌리 토큰을 기본 토큰으로 교환합니다.
10. 스왑 완료가 트리거 되어 대출자와 차입자에 대한 기본 토큰 지급금을 계산합니다.
11. 마지막으로 모두가 초기 보증금 + 이자(지급금)를 인출할 수 있습니다.

## 관찰 사항

Bloom에서 차입자가 되려면 오프체인 KYC 프로세스를 거쳐 주소가 화이트리스트에 등록됩니다. 그 이유는 차입자가 실제로 재무부 채권을 구매하는 것과 관련된 규정 때문입니다.

경제 모델은 다음과 같습니다:

- 차입자는 연방 기금 금리 - 1%(약 4.25%)의 이자율을 지불합니다.
- 차입자는 연방 기금 금리(약 5.25%)를 받게 됩니다.
- 기본적으로 차입자는 연방 기금 금리와 그들이 지불하는 이자(5.25 - 4.25 = 1%) 사이의 스프레드에 사용하는 레버리지(예: 50배 레버리지)를 곱하고 프로토콜 수수료를 뺀 금액을 얻게 됩니다.
- 반면 대출자는 차입자로부터 이자(위에서 언급한 약 4.25%)에서 프로토콜 수수료를 뺀 금액을 받습니다. 이점은 KYC를 거칠 필요가 없지만 여전히 ETF 금리에 가까운 수익률을 얻을 수 있다는 것입니다.
- 프로토콜은 대출자와 차입자 수익의 일정 비율인 수수료를 받습니다.

# 위협 모델

## 특권 역할 및 행위자

- 차입자(Borrower) - 담보를 예치하여 레버리지 차입을 수행하여 이자와 ETF 금리 간의 스프레드를 얻습니다.
- 대출자(Lender) - 차입자를 위해 가치를 예치하고 이자를 얻습니다.
- SwapFacility 소유자 - `SwapFacility`에서 스프레드 가격과 풀 주소를 설정할 수 있습니다.
- 시장 조성자(Market maker) - `SwapFacility`에서 화이트리스트에 등록되며 `swap`을 호출하여 기본 토큰과 빌리 토큰 간의 실제 스왑을 실행할 수 있습니다.

## 보안 인터뷰

**Q:** 프로토콜에서 시장 가치가 있는 것은 무엇인가요?

**A:** 민팅되는 BloomPool 토큰과 프로토콜이 보유하고 스왑하는 재무부 채권 토큰입니다.

**Q:** 프로토콜/사용자가 돈을 잃을 수 있는 경우는 언제인가요?

**A:** 초기 예치금을 인출할 수 없거나 예상보다 적은 이자/보상을 받는 경우입니다.

**Q:** 공격자가 목표를 달성할 수 있는 방법에는 어떤 것이 있나요?

**A:** 이자 계산을 악용하거나 메서드를 강제로 되돌리게(revert) 만드는 것입니다.

# 심각도 분류

| 심각도 | 영향: 높음 | 영향: 중간 | 영향: 낮음 |
| --- | --- | --- | --- |
| **가능성: 높음** | 치명적 (Critical) | 높음 (High) | 중간 (Medium) |
| **가능성: 중간** | 높음 (High) | 중간 (Medium) | 낮음 (Low) |
| **가능성: 낮음** | 중간 (Medium) | 낮음 (Low) | 낮음 (Low) |

**영향 (Impact)** - 성공적인 공격으로 인한 기술적, 경제적, 평판적 손해

**가능성 (Likelihood)** - 특정 취약점이 발견되고 악용될 확률

**심각도 (Severity)** - 위험의 전반적인 중요성

# 보안 평가 요약

**_검토 커밋 해시_ - [744ad16b7166bcaca4b74f870a7a851e8bb0c38c](https://github.com/Blueberryfi/Bloom-protocol/commit/744ad16b7166bcaca4b74f870a7a851e8bb0c38c)**

**_수정 검토 커밋 해시_ - [8fa7239ef0c9bc677b5ef3720ededf88547c97de](https://github.com/Blueberryfi/Bloom-protocol/commit/8fa7239ef0c9bc677b5ef3720ededf88547c97de)**

### 범위

다음 스마트 계약이 감사 범위에 포함되었습니다:

- `BloomPool`
- `BPSFeed`
- `MerkleWhitelist`
- `SwapFacility`
- `interfaces/*`
- `lib/*`

심각도 별로 분류된 다음 수의 문제가 발견되었습니다:

- 치명적 & 높음: 2개 문제
- 중간: 4개 문제
- 낮음: 1개 문제

---

# 발견 사항 요약

| ID | 제목 | 심각도 |
| --- | --- | --- |
| [C-01] | `underlyingTokenPrice`의 스케일링으로 인해 자금이 프로토콜에 묶이게 됨 | 치명적 |
| [H-01] | 프로토콜이 스왑에 대한 슬리피지(slippage) 확인을 구현하지 않음 | 높음 |
| [M-01] | 스왑 메커니즘에 기한(deadline) 매개변수가 없음 | 중간 |
| [M-02] | 가격 피드 검증 누락 및 더 이상 사용되지 않는 메서드 사용으로 인해 가격이 0이 될 수 있음 | 중간 |
| [M-03] | 중앙 집중화 공격 벡터가 존재함 | 중간 |
| [M-04] | 전송 수수료(fee-on-transfer) 메커니즘이 있는 토큰은 프로토콜을 망가뜨림 | 중간 |
| [L-01] | `safeApprove` 사용은 `USDT`와 같은 토큰과 호환되지 않을 수 있음 | 낮음 |

# 상세 발견 사항

# [C-01] `underlyingTokenPrice`의 스케일링으로 인해 자금이 프로토콜에 묶이게 됨

## 심각도

**영향:**
높음, 예치된 모든 자금이 프로토콜에 묶이게 되기 때문

**가능성:**
높음, 항상 발생할 것이기 때문

## 설명

`SwapFacility`의 `_getTokenPrices` 메서드에는 다음 코드가 있습니다:

```solidity
underlyingTokenPrice =
    uint256(IOracle(underlyingTokenOracle).latestAnswer()) *
    1e12;
```

`1e12`만큼 스케일링하는 것은 오류입니다. Chainlink의 대부분의 오라클 가격 피드(더 구체적으로는 사용될 것으로 예상되는 `USDC/USD`)는 8 소수점 숫자를 반환하기 때문입니다. 이 `underlyingTokenPrice` 값은 8 소수점인 `billyTokenPrice` 값으로 나누어지므로, 이는 계산 오류와 `_swap` 메서드에서 `outAmount`의 과도한 팽창을 초래합니다. `SwapFacility` 계약은 잔액에 그렇게 많은 토큰을 보유하지 않으므로 `swap` 호출은 항상 되돌려지며(revert), `BloomPool` 계약은 묶인 상태로 남게 됩니다. 즉, 모든 자금이 예치된 상태에서 단계를 더 이상 진행할 수 없습니다.

## 권장 사항

가격을 `1e12`만큼 스케일링하지 마십시오. 사용될 가격 피드를 명확하게 정의하고 소수점이 다른 경우에만 예상되는 소수점 수로 스케일링하십시오.

# [H-01] 프로토콜이 스왑에 대한 슬리피지(slippage) 확인을 구현하지 않음

## 심각도

**영향:**
높음, 큰 가격 변동이 있을 경우 상당한 가치 손실을 초래할 수 있기 때문

**가능성:**
중간, 슬리피지가 처리되지 않지만 특정 시장 조건이 필요하기 때문

## 설명

프로토콜은 `README` 파일에서 `SwapFacility`가 슬리피지 확인을 구현해야 한다고 언급하고 있지만 그렇지 않습니다. 스왑 트랜잭션이 멤풀(mempool)로 전송되었지만 실행될 때까지 시간이 걸리는 경우, 큰 가격 변동이 있을 수 있으며 스왑 반환 값이 처음에 예상했던 것보다 훨씬 낮을 수 있습니다. 이는 프로토콜과 사용자에게 가치 손실이 될 것입니다.

## 권장 사항

`SwapFacility::_swap`에 `minOutAmount` 매개변수를 추가하고 스왑 결과가 적어도 그만큼의 토큰인지 확인하고 그렇지 않으면 되돌리십시오(revert).

# [M-01] 스왑 메커니즘에 기한(deadline) 매개변수가 없음

## 심각도

**영향:**
높음, 스왑이 강제로 큰 슬리피지(또는 허용된 최대치)를 초래할 수 있기 때문

**가능성:**
낮음, 특별한 조건이 필요하기 때문

## 설명

스왑 메커니즘은 다음 공격 벡터로 인해 트랜잭션 기한 메커니즘을 구현해야 합니다:

1. 앨리스가 스왑을 실행하고 슬리피지를 10%로 설정한 후 트랜잭션을 멤풀로 보내지만 가스 수수료가 매우 낮습니다.
2. 채굴자/검증자는 트랜잭션을 보지만 수수료가 매력적이지 않으므로 트랜잭션은 오래되고 오랫동안 보류 중입니다.
3. 일주일 후(예를 들어) 평균 가스 수수료가 채굴자/검증자가 트랜잭션을 실행할 만큼 충분히 낮아지지만 자산 가격이 급격히 변경되었습니다.
4. 이제 앨리스가 받는 가치는 훨씬 낮으며 설정한 최대 슬리피지에 가까울 수 있습니다.

프로토콜의 현재 사례와 같이 슬리피지가 없는 경우 효과는 훨씬 더 나쁩니다.

## 권장 사항

`SwapFacility::_swap` 메서드에 `deadline` 타임스탬프 매개변수를 추가하고 만료 시간이 지난 경우 트랜잭션을 되돌리십시오(revert).

# [M-02] 가격 피드 검증 누락 및 더 이상 사용되지 않는 메서드 사용으로 인해 가격이 0이 될 수 있음

## 심각도

**영향:**
높음, 0 가격을 사용하면 스왑 계산이 엉망이 되기 때문

**가능성:**
낮음, 가격 피드 오작동이 필요하기 때문

## 설명

`SwapFacility`의 `_getTokenPrices` 메서드는 Chainlink 가격 피드의 `latestAnswer` 메서드를 사용합니다. 문제는 `latestAnswer`의 NatSpec이 다음과 같이 말한다는 것입니다:

> @dev #[deprecated] Use latestRoundData instead. This does not error if no
> answer has been reached, it will simply return 0. Either wait to point to
> an already answered Aggregator or use the recommended latestRoundData
> instead which includes better verification information.```

따라서 현재 `latestAnswer`가 0을 반환하고 코드가 0 가격으로 작동하여 `underlyingToken` 대 `billyToken` 비율 계산에 오류가 발생하여 자금 손실로 이어질 수 있습니다.

## 권장 사항

주석에서 지적한 대로 `latestRoundData`를 대신 사용하여 가격 피드를 쿼리 하십시오.

# [M-03] 중앙 집중화 공격 벡터가 존재함

## 심각도

**영향:**
높음, 사용자에 대한 프로토콜을 망가뜨릴 수 있기 때문

**가능성:**
낮음, 악의적이거나 침해된 소유자가 필요하기 때문

## 설명

`SwapFacility`의 `owner`는 언제든지 `pool` 변수를 변경할 수 있습니다. 예를 들어 `address(0)`으로 설정하여 프로토콜의 `swap` 기능을 망가뜨릴 수 있습니다. 또 다른 문제는 `setSpreadPrice` 메서드가 입력 검증을 수행하지 않는다는 것입니다. 즉, `spreadPrice`를 토큰 가격보다 큰 엄청난 숫자로 설정하여 스프레드 뺄셈으로 인해 매번 `swap` 트랜잭션을 되돌릴 수 있습니다.

## 권장 사항

`setPool`을 한 번만 호출할 수 있게 하고 `spreadPrice` 값의 상한을 두십시오.

# [M-04] 전송 수수료(fee-on-transfer) 메커니즘이 있는 토큰은 프로토콜을 망가뜨림

## 심각도

**영향:**
높음, 일부 사용자가 가치를 잃을 것이기 때문

**가능성:**
낮음, 그러한 토큰은 흔하지 않기 때문

## 설명

`BloomPool`의 ERC20 로직은 전송 수수료 메커니즘이 있는 토큰과 호환되지 않습니다. 예를 들어 `PAXG`가 그러한 토큰이며, `USDT`에는 현재 꺼져 있는 내장된 전송 수수료 메커니즘이 있습니다. `BloomPool::depositBorrower`의 다음 코드가 그 예입니다:

```solidity
UNDERLYING_TOKEN.safeTransferFrom(msg.sender, address(this), amount);
```

토큰에 전송 수수료 메커니즘이 있으면 이 코드는 올바르게 작동하지 않습니다. 계약은 `amount`를 예상 추가 잔액으로 캐시 하지만 실제로 `amount - fee` 잔액을 추가합니다. 이로 인해 계약에서 마지막으로 토큰을 인출하는 사람이 되돌려지게(revert) 됩니다. 프로토콜로 토큰을 전송하는 다른 `transferFrom` 호출(예: `SwapFacility::_swap`)에도 동일하게 적용됩니다.

## 권장 사항

계약으로 `transferFrom`하기 전에 잔액을 캐시 한 다음 전송 후 확인하고 그 차이를 새로 추가된 잔액으로 사용해야 합니다. 그렇지 않으면 ERC777 토큰이 이를 조작할 수 있으므로 `nonReentrant` 수정자가 필요합니다. 또 다른 해결책은 전송 수수료 메커니즘이 있는 토큰을 지원하지 않는다고 문서화하고 알리는 것입니다.

# [L-01] `safeApprove` 사용은 `USDT`와 같은 토큰과 호환되지 않을 수 있음

일부 토큰은 승인 경쟁 보호 메커니즘(`USDT`, `KNC`)을 구현하여 사전 승인 허용량이 0이거나 `type(uint256).max` 여야 합니다. 현재 `initiatePreHoldSwap`의 코드는 `UNDERLYING_TOKEN`에 대해 `safeApprove`를 사용합니다. 이전 허용량이 0이 될 때까지 사용되지 않은 경우 `USDT`가 `UNDERLYING_TOKEN`이면 코드는 `safeApprove` 호출에서 되돌려집니다. 이 경우를 적절하게 다루기 위해 OpenZeppelin 4.9.1 `SafeERC20`의 `forceApprove`를 사용하는 것이 좋습니다.
