# 소개

**Cadmos Finance** 프로토콜에 대한 시간 제한 보안 검토가 **pashov**에 의해 수행되었으며, 애플리케이션 구현의 보안 측면에 중점을 두었습니다.

# 면책 조항

스마트 계약 보안 검토는 취약점의 완전한 부재를 절대 확인할 수 없습니다. 이는 시간, 자원 및 전문 지식이 제한된 노력으로 최대한 많은 취약점을 찾으려고 노력하는 것입니다. 검토 후 100% 보안을 보장할 수 없으며, 검토가 스마트 계약의 문제를 발견할 것이라고 보장할 수도 없습니다.

# 프로토콜 개요

프로토콜에는 세 가지 주요 행위자 유형이 있습니다:

1. 투자자(Investors) - 프로토콜의 사용자이며, 자본을 예치하고 수익을 기대합니다.
2. 전략가(Strategists) - 재무 자금에 대한 높은 수익률을 목표로 프로토콜 재무부를 관리하는 행위자입니다.
3. 관리자(Administrators) - 예를 들어 전략가의 성과를 계산하고 온체인에 기록하여 오프체인 오라클 역할을 함으로써 투자 풀(Investment Pools)을 관리합니다.

일반적인 사용 흐름은 다음과 같습니다:

1. 투자자는 정산 풀(Settlement Pool)에 자본(예: `DAI` 토큰)을 예치하고 정산 풀 토큰(ERC20)을 돌려받습니다.
2. 어느 시점에 관리자가 정산 풀에서 예치된 자금을 투자 풀로 가져오기 위해 트랜잭션을 트리거 합니다.
3. 이제 관리자는 예치된 자금을 다시 투자 풀에서 재무부로 옮깁니다.
4. 전략가는 예치된 자금에 대한 투자 접근 방식을 미세 조정하여 풀 순자산 가치(Net Asset Value)를 높일 수 있습니다.
5. 잠시 후, 투자자는 투자 풀 토큰을 소각하여 초기 자본과 누적된 수익을 상환할 수 있습니다.

**투자 풀의 청산 상태**

투자 풀의 관리자는 언제든지 청산 상태로 만들 수 있습니다. 이는 풀에 몇 가지 제약 조건을 적용하며 가장 중요한 것은 다음과 같습니다:

1. 예치 불가
2. 풀 재무부로의 전송 불가
3. 모든 보상은 0으로 설정
4. 풀 상태 변경 불가

투자 풀이 청산 상태일 때 투자자는 `InvestmentPoolCore::liquidate`를 호출하여 예치금을 직접 인출할 수 있습니다.

전략가와 관리자 모두 사용자 자금을 이동시키는 데 큰 권한을 가지고 있으므로 시스템에서 100% 신뢰되어야 합니다.

# 심각도 분류

| 심각도 | 영향: 높음 | 영향: 중간 | 영향: 낮음 |
| --- | --- | --- | --- |
| **가능성: 높음** | 치명적 (Critical) | 높음 (High) | 중간 (Medium) |
| **가능성: 중간** | 높음 (High) | 중간 (Medium) | 낮음 (Low) |
| **가능성: 낮음** | 중간 (Medium) | 낮음 (Low) | 낮음 (Low) |

# 보안 평가 요약

**_검토 커밋 해시_ - [a3754f182851ce90f33f514e6f0bd1dd2d539cdb](https://github.com/Cadmos-finance/InvestmentPool/tree/a3754f182851ce90f33f514e6f0bd1dd2d539cdb)**

### 범위

다음 스마트 계약이 감사 범위에 포함되었습니다:

- `InvestmentPoolCore`
- `InvestmentPoolFactory`
- `ProtocolRegistry`
- `SettlementPool`
- `SimpleAdministrator`
- `Whitelist`

심각도 별로 분류된 다음 수의 문제가 발견되었습니다:

- 중간: 5개 문제
- 낮음: 6개 문제
- 정보성: 6개 문제

---

# 발견 사항 요약

| ID | 제목 | 심각도 |
| --- | --- | --- |
| [M-01] | 가스 비용 하드코딩은 피해야 함 | 중간 |
| [M-02] | `assetToken`이 다중 주소 토큰인 경우 `transferERC20ToTreasury`가 의도한 대로 작동하지 않음 | 중간 |
| [M-03] | 주요 관리자 작업의 프런트 러닝 위험 | 중간 |
| [M-04] | 관리자 작업의 중요한 흐름이 강제되지 않고 문서화만 되어 있음 | 중간 |
| [M-05] | 단일 단계 소유권 이전은 위험할 수 있음 | 중간 |
| [L-01] | 계약이 인터페이스 계약을 직접 구현하지 않음 | 낮음 |
| [L-02] | 취약한 라이브러리 버전이 포함된 OpenZeppelin의 `ECDSA` 사용 | 낮음 |
| [L-03] | InvestmentPoolCore::setWhitelistOnly에서 입력 검증 누락 | 낮음 |
| [L-04] | 이벤트 방출 누락 | 낮음 |
| [L-05] | 플래그가 너무 많은 목적을 가짐 | 낮음 |
| [L-06] | 잘못된 NatSpec/구현 | 낮음 |
| [I-01] | 프로토콜이 오래된 Solidity 버전을 사용 중임 | 정보성 |
| [I-02] | 모든 메서드에 `nonReentrant` 수정자가 있음 | 정보성 |
| [I-03] | `cancelDeposit`에서 잔액이 0인지 확인 | 정보성 |
| [I-04] | 사용되지 않는 이벤트는 제거할 수 있음 | 정보성 |
| [I-05] | 사용되지 않는 import는 제거할 수 있음 | 정보성 |
| [I-06] | 화이트리스팅 모드는 열거형(enum)으로 처리해야 함 | 정보성 |

# 상세 발견 사항

# [M-01] 가스 비용 하드코딩은 피해야 함

## 심각도

**가능성:**
중간, 가스 비용 변경이 이전에 발생했지만 프로토콜에 영향을 미치는 변경이 있을지는 확실하지 않기 때문입니다.

**영향:**
낮음, 계산이 틀리더라도 오프체인에서 여전히 수행할 수 있기 때문입니다.

## 설명

`SimpleAdministrator`의 `markCost` 수정자는 예를 들어 21000(EVM 트랜잭션의 기본 비용)과 같은 일부 하드 코딩된 가스 비용 값을 가지고 있습니다. 우리는 이전 EVM 포크에서 SSTORE opcode와 같은 몇 가지 주요 사항의 가스 비용을 변경하는 것을 보았습니다. 이것은 다시 발생할 수 있으며 이 경우 `markCost`의 하드 코딩된 값은 더 이상 올바르지 않아 발생한 가스 비용에 대한 잘못된 회계 처리로 이어질 수 있습니다. 또한 프로젝트가 다른 EVM 호환 체인에 배포되면 거기서 가스 비용이 다를 수 있습니다.

## 권장 사항

`initialize` 메서드에서 예상 가스 비용을 초기화하고 EVM 포크의 경우 업데이트할 수 있는 설정자(setter) 함수를 추가하십시오.

## 논의

### CADMOS

인지됨 - 수정됨.

# [M-02] `assetToken`이 다중 주소 토큰인 경우 `transferERC20ToTreasury`가 의도한 대로 작동하지 않음

## 심각도

**가능성:**
낮음, 다중 주소 토큰을 사용하고 악의적이거나 침해된 관리자가 필요하기 때문입니다.

**영향:**
높음, 사용자가 예치금의 100%를 사용할 수 있기 때문입니다.

## 설명

블록체인의 일부 ERC20 토큰은 프록시 뒤에 배포되므로 기능에 대해 최소 2개의 진입점(프록시 및 구현)을 가집니다. 예를 들어 `sUSD, sBTC` 등과 상호 작용할 수 있는 Synthetix의 `ProxyERC20` 계약이 있습니다. 이러한 토큰이 투자 풀에서 `assetToken`으로 사용된 경우 관리자는 다음 확인이 있더라도 `transferERC20ToTreasury` 메서드로 모든 예금자를 러그(rug)할 수 있습니다:

```solidity
require(tokenAddress != _assetTokenAddress, "IP: Asset transfer");
```

토큰에는 여러 주소가 있으므로 관리자는 다른 주소를 제공하고 해당 확인을 통과할 수 있습니다.

## 권장 사항

전송된 토큰의 주소를 확인하는 대신 전송 전후의 잔액을 확인하고 동일한지 확인하는 것이 더 좋은 접근 방식입니다.

## 논의

### CADMOS

인지됨 - 수정됨.

# [M-03] 주요 관리자 작업의 프런트 러닝 위험

## 심각도

**가능성:**
중간, 악의적인 사용자가 공개 멤풀을 모니터링하는 스크립트를 가지고 있어야 하기 때문입니다.

**영향:**
중간, 주요 관리자 기능이 되돌려질(revert) 것이기 때문입니다.

## 설명

`InvestmentPoolCore` 및 `Whitelist`의 `forceTransfer`, `whitelistAccount` 및 `freezeAccount` 메서드는 트랜잭션을 모니터링하고 프런트 러닝될 수 있습니다. 다음 시나리오를 상상해 보십시오:

1. 밥은 `InvestmentPool` ERC20 토큰을 보유하고 있습니다.
2. 어떤 이유로 `TOKEN_FREEZE_ROLE` 보유자가 밥이 악의적이라고 판단하여 그의 잔액을 동결해야 한다고 결정하므로 `Whitelist::freezeAccount`를 호출합니다.
3. 밥은 그것을 예상하고 이미 멤풀을 모니터링하고 있었으므로 자신이 제어하는 다른 주소로 전송 트랜잭션을 수행하여 트랜잭션을 프런트 러닝합니다.
4. 이제 그의 주소는 동결되었지만 새 주소는 동결되지 않았으므로 여전히 토큰을 이동/상환/스왑할 수 있습니다.

동일한 로직이 `whitelistAccount` 및 `forceTransfer` 기능에 적용됩니다.

## 권장 사항

항상 비공개 멤풀을 통해 언급된 함수에 대한 트랜잭션을 실행하거나 프런트 러닝이 불가능하도록 재설계하십시오.

## 논의

### CADMOS

인지됨.

# [M-04] 관리자 작업의 중요한 흐름이 강제되지 않고 문서화만 되어 있음

## 심각도

**가능성:**
낮음, 악의적이거나 침해된 관리자가 있거나 관리자가 올바른 작업 흐름을 수행해야 한다는 것을 잊어버려야 하기 때문입니다.

**영향:**
높음, 사용자가 자금을 잃게 되기 때문입니다.

## 설명

`InvestmentPoolCore::setInflowOutflowPool`의 NatSpec에는 다음 주석이 포함되어 있습니다:

```solidity
    /// @notice call batchSettlement(id) beforehand, otherwise it will rug the old pool tokenholders
```

메서드 호출을 실행할 때 이를 쉽게 잊어버리거나 놓칠 수 있습니다. 올바른 작업 흐름이 사용되도록 보장하는 이 방법은 오류가 발생하기 쉽습니다.

## 권장 사항

플래그나 일부 저장소 변수를 사용하여 사전에 `batchSettlement(id)`가 호출되었는지 확인하여 사용자가 러그되지 않도록 하십시오.

## 논의

### CADMOS

인지됨 - 수정됨.

# [M-05] 단일 단계 소유권 이전은 위험할 수 있음

## 심각도

**가능성:**
낮음, 관리자 측의 오류가 필요하기 때문입니다.

**영향:**
높음, 프로토콜이 벽돌(bricked)이 될 수 있기 때문입니다.

## 설명

단일 단계 소유권 이전은 소유권이나 관리자 권한을 이전할 때 잘못된 주소가 전달되면 해당 역할을 영원히 잃을 수 있음을 의미합니다. 이는 `InvestmentPoolCore`의 맥락에서 해로울 수 있는데, `transferAdminRole` 메서드가 잘못된 `newAdmin` 주소로 호출되면 `InvestmentPoolCore` 계약은 관리자 전용 메서드에 크게 의존하므로 벽돌이 될 것이기 때문입니다.

## 권장 사항

2단계 소유권 이전 패턴을 사용하는 것이 모범 사례입니다. 즉, 소유권 이전이 "보류 중(pending)" 상태가 되고 새 소유자가 새 권한을 청구해야 합니다. 그렇지 않으면 이전 소유자가 여전히 계약을 제어합니다.

## 논의

### CADMOS

인지됨 - 수정됨:

- ProtocolRegistry는 이제 Ownable 대신 Ownable2Step입니다.
- InvestmentPool 관리자를 위한 2단계 전송. 역할 변경
- simpleAdmin에서 2단계 관리자 권한 전송.

# [L-01] 계약이 인터페이스 계약을 직접 구현하지 않음

`contracts/`의 모든 계약에 대해 `interfaces/`에 인터페이스 계약이 있지만 직접 사용되지는 않습니다. 즉, 코드가 컴파일러 검사를 사용하지 않기 때문에 일부 메서드가 실제로 재정의(override)되지 않을 수 있습니다. 구현 계약이 인터페이스 계약을 직접 상속하는지 확인하십시오.

## 논의

### CADMOS

인지됨 - 수정됨.

# [L-02] 취약한 라이브러리 버전이 포함된 OpenZeppelin의 `ECDSA` 사용

코드베이스는 OpenZeppelin 종속성에 `4.4.0` 버전을 사용하지만 이 버전에는 ECDSA와 관련된 높은 심각도 취약점이 있습니다 - [참조](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h)
코드가 현재 상태에서 악용될 수 없더라도 OpenZeppelin 라이브러리 종속성을 최신 보안 버전(4.7.3)으로 업그레이드하는 것이 가장 좋습니다.

## 논의

### CADMOS

인지됨 - 4.8.0으로 상향 조정됨.

# [L-03] InvestmentPoolCore::setWhitelistOnly에서 입력 검증 누락

`flag` 인수의 유일하게 올바른 값은 0, 1 또는 2입니다. `require` 문으로 검증해야 합니다.

## 논의

### CADMOS

인지됨 - 수정됨.

# [L-04] 이벤트 방출 누락

`SimpleAdministrator`의 `_newAdmin` 메서드는 이벤트를 방출하지 않지만 관리자 추가를 오프체인에서 쉽게 추적할 수 있는 것이 중요하므로 방출해야 합니다. `_newAdmin`에서 적절한 이벤트를 방출하십시오.
`Whitelist`의 `whitelistOffChain` 메서드도 마찬가지입니다. `Whitelisted` 이벤트를 방출해야 합니다.

## 논의

### CADMOS

- \_newAdmin은 `AdminRightsChanged(newAdmin, 0, flag)`를 방출합니다.
- `whitelistOffChain`에 대해 인지됨 - 수정됨.

# [L-05] 플래그가 너무 많은 목적을 가짐

`SimpleAdministrator`의 `setTreasury` 메서드는 `FLAG_STRAT_CHANGE` 플래그를 요청하지만 해당 작업에는 고유한 플래그(예: `FLAG_TREASURY_CHANGE`)를 갖는 것이 좋습니다. 이 기능에 대한 별도의 플래그를 추가하십시오.

## 논의

### CADMOS [24/12/2022]

인지됨 - 수정됨.

# [L-06] 잘못된 NatSpec/구현

`SimpleAdministrator`의 `setNewSoftHurdleRate` 메서드는 "FLAG_HURDLE_RATE_CHANGE를 통해 활성화/비활성화"라고 말하지만 실제로는 `FLAG_REWARD_CHANGE`를 사용합니다. 플래그 검증 또는 NatSpec을 적절하게 업데이트하십시오.

## 논의

### CADMOS

인지됨 - 수정됨.

# [I-01] 프로토콜이 오래된 Solidity 버전을 사용 중임

프로토콜은 Solidity 컴파일러 버전 0.8.3을 사용하고 있지만 최신 버전은 0.8.17입니다. 버전을 업그레이드하면 사용자 지정 오류(Custom Errors)와 같은 많은 기능과 최적화를 얻을 수 있습니다.

## 논의

### CADMOS

인지됨 - 0.8.7로 상향 조정됨

# [I-02] 모든 메서드에 `nonReentrant` 수정자가 있음

메서드에 외부 호출이 없으면 재진입이 불가능하므로 이러한 메서드에서는 이 수정자를 건너뛸 수 있습니다.

## 논의

### CADMOS

인지됨 - 함수가 다른 함수로 재진입할 수는 없지만 그 자체로 재진입할 수 있으므로 주의해서 수행해야 합니다.

# [I-03] `cancelDeposit`에서 잔액이 0인지 확인

`SettlementPool`의 `cancelDeposit` 메서드에는 호출자의 잔액이 0보다 큰지 확인하는 기능이 누락되어 있습니다.

## 논의

### CADMOS

인지됨 - 수정됨.

# [I-04] 사용되지 않는 이벤트는 제거할 수 있음

`SettlementPool`의 `ForcedTransfer` 이벤트는 사용되지 않으므로 제거할 수 있습니다.

## 논의

### CADMOS

인지됨 - 수정됨.

# [I-05] 사용되지 않는 import는 제거할 수 있음

`ReentrancyGuard` 스마트 계약은 `ProtocolRegistry`에서 가져오지만 사용되지 않으므로 제거할 수 있습니다.

## 논의

### CADMOS

인지됨 - 수정됨.

# [I-06] 화이트리스팅 모드는 열거형(enum)으로 처리해야 함

`_BLACKLISTMODE`, `_WHITELISTPRIMARY` 및 `_WHITELISTALL` 모드는 `WhitelistMode` 열거형으로 전환되어야 합니다.

## 논의

### CADMOS

인지됨 - 수정됨
