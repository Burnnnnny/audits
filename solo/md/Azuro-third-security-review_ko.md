# 소개

**Azuro** 프로토콜에 대한 시간 제한 보안 검토가 **pashov**에 의해 수행되었으며, 애플리케이션 구현의 보안 측면에 중점을 두었습니다.

# 면책 조항

스마트 계약 보안 검토는 취약점의 완전한 부재를 절대 확인할 수 없습니다. 이는 시간, 자원 및 전문 지식이 제한된 노력으로 최대한 많은 취약점을 찾으려고 노력하는 것입니다. 검토 후 100% 보안을 보장할 수 없으며, 검토가 스마트 계약의 문제를 발견할 것이라고 보장할 수도 없습니다. 후속 보안 검토, 버그 바운티 프로그램 및 온체인 모니터링을 강력히 권장합니다.

# **pashov** 소개

Krum Pashov 또는 **pashov**는 독립적인 스마트 계약 보안 연구원입니다. 다양한 프로토콜에서 수많은 보안 취약점을 발견한 그는 보안 연구 및 검토에 시간과 노력을 투자하여 블록체인 생태계와 프로토콜에 기여하기 위해 최선을 다합니다. Twitter [@pashovkrum](https://twitter.com/pashovkrum)으로 연락할 수 있습니다.

# **Azuro** 소개

**이전 보안 검토에서 복사됨**

Azuro는 탈중앙화 베팅 프로토콜입니다. 누구나 스마트 계약에 연결하는 프런트엔드 서비스를 시작할 수 있으며 해당 프런트엔드를 통해 이루어진 각 베팅에 대해 제휴 보너스를 받을 수 있습니다. 축구 경기와 같은 다양한 베팅 이벤트를 호스팅 할 수 있습니다. 배당률은 초기화를 위해 데이터 피드 제공자(오라클)에 의해 한 번 제공된 다음 플랫폼의 베팅에 따라 변경됩니다. 사용자 베팅은 사용자 지갑의 NFT로 자동 변환됩니다.

**계속**

`SuperExpress` 기능을 사용하면 이전에 고정된 15개의 이벤트 결과에 베팅할 수 있습니다. 베팅은 라운드가 시작될 때까지 허용됩니다. 베터는 라운드의 15개 이벤트 각각에 대해 세 가지 가능한 결과 중 하나를 선택할 수 있습니다. 최소 9개의 이벤트 결과를 올바르게 추측하면 베팅은 당첨 베팅이며 상금 기금에서 비례 배분된 상금을 받습니다. 베팅에서 최소 14개의 이벤트 결과를 올바르게 추측하면 `AZUR` 토큰 형태의 슈퍼 상금 기금의 일부도 받게 됩니다. 슈퍼 상금 기금의 일부가 지급될 때마다 라운드를 "슈퍼 라운드"라고 합니다. 상금 기금은 라운드의 베팅에서 조달되지만 슈퍼 상금 기금은 유동성 공급자(로직은 `LP` 계약)로부터 나옵니다.

## 관찰 사항

`SuperExpress` 및 `LP` 계약은 모두 업그레이드 가능하며 이는 프로토콜과 사용자에게 중앙 집중화 위험을 초래합니다.
`SuperExpress` 관리자는 활성 라운드를 취소하고 당첨 결과를 변경할 수 있으므로 플랫폼에서 이루어진 베팅에 대한 전적인 통제 권한을 갖습니다. 또한 LP, 프런트엔드 또는 DAO 수수료를 각각 100%로 설정하거나 세 가지 모두를 합하여 100%가 되도록 할 수 있습니다.

# 위협 모델

## 특권 역할 및 행위자

- LP의 SuperExpress - `LP`의 기능을 사용할 수 있는 유일한 계정
- LP 관리자 - `superExpress` 계정 주소를 설정할 수 있음
- SuperExpress 관리자 - 베팅 라운드에 대한 전적인 통제 권한을 가지며 라운드를 추가, 취소, 완료하고 당첨 결과를 설정하며 계약 수수료 및 `betNominal`을 설정할 수 있음
- 슈퍼 상금 유동성 공급자 - 슈퍼 상금 기금을 위해 `SuperExpress`에 Azuro 토큰을 예치하고 각 베팅에서 수수료를 청구할 수 있음
- 베터(Bettor) - 베팅을 할 수 있음 (자신 또는 다른 계정을 위해 하나 또는 여러 개)
- 프런트엔드 추천인(Front-end referral) - `SuperExpress`에서 자신을 통해 이루어진 베팅에서 추천 수수료를 청구할 수 있음
- DAO - `SuperExpress`의 베팅에서 `collectedDaoFee`를 인출할 수 있음

## 보안 인터뷰

**Q:** 프로토콜에서 시장 가치가 있는 것은 무엇인가요?

**A:** 상금 및 슈퍼 상금 기금은 경제적 가치가 있습니다.

**Q:** 프로토콜/사용자가 돈을 잃을 수 있는 경우는 언제인가요?

**A:** 베팅 당첨금이나 제공된 슈퍼 상금 유동성을 인출할 수 없는 경우입니다.

**Q:** 공격자가 목표를 달성할 수 있는 방법에는 어떤 것이 있나요?

**A:** 보상 지급, 수수료 또는 LP 지급 계산을 악용하는 것입니다.

# 심각도 분류

| 심각도 | 영향: 높음 | 영향: 중간 | 영향: 낮음 |
| --- | --- | --- | --- |
| **가능성: 높음** | 치명적 (Critical) | 높음 (High) | 중간 (Medium) |
| **가능성: 중간** | 높음 (High) | 중간 (Medium) | 낮음 (Low) |
| **가능성: 낮음** | 중간 (Medium) | 낮음 (Low) | 낮음 (Low) |

**영향 (Impact)** - 성공적인 공격으로 인한 기술적, 경제적, 평판적 손해

**가능성 (Likelihood)** - 특정 취약점이 발견되고 악용될 확률

**심각도 (Severity)** - 위험의 전반적인 중요성

# 보안 평가 요약

**_검토 커밋 해시_ - [3369c3ea9e6289704644cf5dcb845e0e8d61766b](https://github.com/Azuro-protocol/SuperExpress/tree/3369c3ea9e6289704644cf5dcb845e0e8d61766b)**

### 범위

다음 스마트 계약이 감사 범위에 포함되었습니다:

- `SuperExpress`
- `LP`
- `libraries/FixedMath`

심각도 별로 분류된 다음 수의 문제가 발견되었습니다:

- 치명적 & 높음: 1개 문제
- 중간: 1개 문제
- 낮음: 3개 문제

---

# 발견 사항 요약

| ID | 제목 | 심각도 |
| --- | --- | --- |
| [C-01] | 프런트엔드 소유자가 모든 베팅 잔액을 훔칠 수 있음 | 치명적 |
| [M-01] | 수수료 비율의 합계가 관리자가 제공한 `total` 값과 동일하지 않을 수 있음 | 중간 |
| [L-01] | `FixedMath` 라이브러리를 사용한 곱셈 전 나눗셈 | 낮음 |
| [L-02] | 베터가 라운드에 베팅할 시간이 없을 수 있음 | 낮음 |
| [L-03] | 로컬 변수에 값을 설정한 후 재할당 | 낮음 |

# 상세 발견 사항

# [C-01] 프런트엔드 소유자가 모든 베팅 잔액을 훔칠 수 있음

## 심각도

**영향:**
높음, 프로토콜 및 사용자에게 100% 손실을 초래하기 때문

**가능성:**
높음, 모든 Azuro SuperExpress 프런트엔드 소유자가 이를 악용할 수 있기 때문

## 설명

Azuro 프로토콜은 모든 프런트엔드 소유자가 자신의 UI를 통해 이루어진 각 베팅에 자신의 주소를 추가할 수 있도록 허용합니다. `SuperExpress`에서 이 주소는 각 베팅에서 가져온 수수료 금액(약간의 비율)을 인출할 수 있습니다. 문제는 이것이 발생하는 `withdrawFrontFee` 메서드에 결함이 있다는 것입니다. 이 메서드는 계약에 베팅 토큰 잔액이 더 이상 없을 때까지 루프에서 여러 번 호출될 수 있습니다.

결함은 메서드가 다음을 수행하더라도:

```solidity
round.frontRewarded[msg.sender] = true;
```

이는 프런트엔드 소유자가 보상을 다시 청구하는 것을 막으려는 시도이지만, 어디에서도 확인되지 않는다는 것입니다. `_viewFrontFee` 메서드는 이미 청구된 "front" 보방을 고려해야 하지만 그렇지 않습니다.

## 권장 사항

`_viewFrontFee`에서 `round.frontRewarded[msg.sender] == true`인지 확인하고 그렇다면 0을 반환하도록 하십시오.

# [M-01] 수수료 비율의 합계가 관리자가 제공한 `total` 값과 동일하지 않을 수 있음

## 심각도

**영향:**
높음, 계약의 회계를 엉망으로 만들어 자금이 묶이거나 손실될 수 있기 때문

**가능성:**
낮음, 관리자 측의 실수나 오류가 필요하기 때문

## 설명

`_changeFee` 메서드에서 `newFeePercents`에 대한 입력 유효성 검사는 다음과 같습니다:

```solidity
       if (
            (newFeePercents.lp + newFeePercents.front + newFeePercents.dao) >
            FixedMath.ONE ||
            newFeePercents.total > FixedMath.ONE
        ) revert IncorrectValue();
```

수수료 비율의 합계와 총값이 100%를 넘지 않는지 검증하지만, 세 가지 다른 수수료 비율의 합이 `total` 값과 같지 않을 수 있습니다. 이제 실제로 다른 값이 되면 계약의 회계가 엉망이 됩니다. 사용자가 베팅을 할 때 `fee.total`이 베팅 금액에서 제거되지만 수수료 수령자에게는 다른 값이 전송되기 때문입니다. 이로 인해 자금이 묶이거나 프로토콜 및 사용자에게 직접적인 가치 손실이 발생합니다.

## 권장 사항

코드를 다음과 같이 변경하십시오:

```diff
       if (
-            (newFeePercents.lp + newFeePercents.front + newFeePercents.dao) >
-            FixedMath.ONE ||
+            (newFeePercents.lp + newFeePercents.front + newFeePercents.dao) != newFeePercents.total ||
            newFeePercents.total > FixedMath.ONE
        ) revert IncorrectValue();
```

# [L-01] `FixedMath` 라이브러리를 사용한 곱셈 전 나눗셈

`LP`의 `withdrawView` 메서드에는 다음 코드가 있습니다:

```solidity
amount = shareAmount.mul(
       superRound_.totalPrizeFund.div(superRound_.totalShare)
);
```

여기서 `div` 메서드는 `mul` 메서드 이전에 호출되는데, 이는 곱셈 전 나눗셈입니다. `FixedMath` 라이브러리에서 해당 메서드가 작동하는 방식 때문에 현재 문제가 되지는 않지만, Solidity에서는 항상 나눗셈 전에 곱셈을 하는 것이 관례이자 모범 사례입니다. 제안 사항은 코드를 다음과 같이 변경하는 것입니다:

```solidity
amount = (shareAmount.mul(superRound_.totalPrizeFund)).div(superRound_.totalShare);
```

# [L-02] 베터가 라운드에 베팅할 시간이 없을 수 있음

현재 `addRound` 메서드는 `block.timestamp`를 `round.start` 값으로 설정할 수 있도록 허용합니다. 문제는 `_putBet`에서 `block.timestamp >= round.start`이면 트랜잭션이 되돌려진다는 것입니다. 사용자가 베팅할 수 있도록 보장하기 위해 라운드가 시작되기 전 기간의 최소값(예: 1일)을 설정하는 것이 좋습니다.

# [L-03] 로컬 변수에 값을 설정한 후 재할당

`SuperExpress::resolveRound`에 이 할당이 있습니다:

```solidity
uint256 roundFeeLP = round.feeLP;
```

하지만 몇 줄 아래에 이것이 있습니다:

```solidity
roundFeeLP = compoundRoundFee_.mul(feePercents_.lp);
```

실제로 첫 번째 것을 덮어씁니다. 이는 개발자의 잠재적으로 다른 의도를 보여주거나 필요하지 않습니다. 이것이 올바른 구현이어야 하므로 값을 지정하지 않고 `roundFeeLP`를 선언하는 것이 좋습니다.
